---
title: DBS101 Unit7  
categories: [DBS101, Unit7]  
tags: [DBS101]  
---

# Unit VII: Transactions, Concurrency & Recovery â€“ Databases That Heal Themselves

## ğŸ“Œ Introduction

This unit uncovers the superpowers that keep our data consistent, available, and durable â€” even when the system crashes, power goes out, or users mess up.  

Welcome to the world of:
- âœ… **Transactions** (Lesson 18)  
- ğŸ”’ **Concurrency Control** (Lesson 19)  
- ğŸ” **Database Recovery** (Lesson 20)

---

## ğŸ§¾ Lesson 18: Transactions & ACID â€“ Making Promises You Can Keep

### ğŸ§© What is a Transaction?
A transaction = a unit of work (like a bank transfer or an inventory update) that must either complete fully or not at all.

### ACID Properties

| Property     | Purpose                              |
|--------------|---------------------------------------|
| Atomicity     | All or nothing                       |
| Consistency   | No data corruption                   |
| Isolation     | No interference from other transactions |
| Durability    | Changes survive crashes              |

> ğŸ’¡ SQL Example:
> ```sql
> BEGIN;
> UPDATE accounts SET balance = balance - 50 WHERE account_name = 'A';
> UPDATE accounts SET balance = balance + 50 WHERE account_name = 'B';
> COMMIT;
> ```

### Storage Types That Support ACID

| Type             | Description                        |
| ---------------- | ---------------------------------- |
| **Volatile**     | RAM â€“ fast but not crash-proof     |
| **Non-Volatile** | Disks â€“ durable but slower         |
| **Stable**       | Redundant, reliable storage (RAID) |

> ğŸ’¡ Durability relies on writing to stable storage before committing.

### Transaction Lifecycle

| State                   | What Happens                          |
| ----------------------- | ------------------------------------- |
| **Active**              | Execution in progress                 |
| **Partially Committed** | Final operations done                 |
| **Failed**              | Error occurred, can't proceed         |
| **Aborted**             | Rolled back to safe state             |
| **Committed**           | Successfully completed, changes saved |

### Serializability â€” Order in the Chaos
To preserve consistency with multiple transactions, databases ensure serializability â€” the outcome is the same as if transactions were run one-by-one.

> - âœ… Serial Schedule: T1 â†’ T2
> - âœ… Serializable: Looks like a serial execution
> - âŒ Non-serial but inconsistent: Database disaster!

### Conflict Serializability and Precedence Graphs
Use Precedence Graphs:
- Nodes = transactions
- Edge T1 â T2 = T1 must come before T2 due to a conflict

>- ğŸ” No cycles = âœ… Serializable
>- ğŸ”„ Cycles = âŒ Not serializable

### Recoverable vs. Cascadeless Schedules

| Schedule Type   | Rule                                      |
| --------------- | ----------------------------------------- |
| **Recoverable** | Don't commit if you read uncommitted data |
| **Cascadeless** | Don't even read uncommitted data!         |

### Isolation Levels

| Level                | Isolation Strength            |
| -------------------- | ----------------------------- |
| **Serializable**     | Strongest â€“ like serial       |
| **Repeatable Read**  | Stable reads, no phantom rows |
| **Read Committed**   | Canâ€™t read dirty data         |
| **Read Uncommitted** | ğŸ˜± May read dirty data        |

---

## ğŸ”€ Lesson 19: Concurrency Control â€“ Keeping Transactions from Colliding
### ğŸ” Why Locks?
Locks help transactions access data safely and prevent conflicts:
- Shared (S): Read-only access
- Exclusive (X): Read + Write access

> âš ï¸ Many S-locks allowed, only one X-lock!

### Two-Phase Locking (2PL)

| Phase     | Rule               |
| --------- | ------------------ |
| Growing   | Acquire locks only |
| Shrinking | Release locks only |

âœ… Guarantees serializability
âŒ May cause deadlocks

### Deadlocks & Solutions

| Strategy   | Action                                     |
| ---------- | ------------------------------------------ |
| Detection  | Use waits-for graph & pick a victim        |
| Prevention | Use timestamp rules (Wait-Die, Wound-Wait) |

### Lock Granularity & Intention Locks

| Level | Example       |
| ----- | ------------- |
| Tuple | Specific row  |
| Page  | Block of rows |
| Table | Entire table  |

> ğŸ§  Use IS/IX/SIX intention locks for hierarchy control.

### Timestamp Ordering (TO)
- Assign timestamps to transactions
- Maintain order to ensure serializability
- Use Thomas Write Rule to reduce aborts

### Multi-Version Concurrency Control (MVCC)
- DBMS keeps multiple versions of data items
- Readers see consistent snapshot
- Writers donâ€™t block readers (and vice versa!)

> ğŸ•° Great for time-travel queries and snapshots

###  Snapshot Isolation (SI)
Every transaction sees a frozen version of the database from when it began.

> âš ï¸ Beware of Write Skew Anomalies â€” two transactions update different values based on outdated shared state.

---

## â™»ï¸ Lesson 20: Recovery â€“ When Things Go Wrong, Databases Fight Back ğŸ’ª
### ğŸ˜± Why Recovery Matters
- Power failures
- Crashes
- Transaction errors
- Natural disasters

> âœ… Transactions must be atomic and durable even after disaster!

### Log-Based Recovery
Every change is recorded in a log BEFORE modifying the actual database.

| Log Format Example | Meaning                     |
| ------------------ | --------------------------- |
| `<Ti, Xj, V1, V2>` | Ti changed Xj from V1 to V2 |
| `<Ti start>`       | Ti started                  |
| `<Ti commit>`      | Ti committed                |
| `<Ti abort>`       | Ti aborted                  |

### Undo & Redo

| Operation    | Action                                |
| ------------ | ------------------------------------- |
| **Undo(Ti)** | Rollback all changes using old values |
| **Redo(Ti)** | Reapply changes using new values      |

> ğŸ”„ After a crash:
> - Undo incomplete transactions
> - Redo committed transactions

### Checkpoints â€“ Recovery Time Boosters

| Type     | Benefit                         |
| -------- | ------------------------------- |
| Standard | Snapshot of active transactions |
| Fuzzy    | Doesnâ€™t block transactions      |

> âœ… Reduces the log scanning needed during recovery

### Log Record Buffering & WAL
- Logs are kept in memory temporarily
- Write-Ahead Logging (WAL) ensures log is written before data is updated

### Steal & No-Force Policies

| Policy       | Description                                   |
| ------------ | --------------------------------------------- |
| **Steal**    | Dirty data may be written before commit       |
| **No-Force** | Committed data may not be written immediately |

### Recovery from Disk Failures
- Periodic full dumps to backup media
- Use dump + redo log to recover from complete disk loss

### Remote Backup Systems

| Technique           | Use Case                      |
| ------------------- | ----------------------------- |
| Log Shipping        | Send logs to remote replica   |
| Hot-Spare Mode      | Backup is nearly always ready |
| Distributed Systems | Multi-site redundancy         |

### ARIES Algorithm (IBM)
A 3-phase recovery strategy:
1. ğŸ” Analysis â€“ What happened?
2. ğŸ”Redo â€“ Replay history
3. âª Undo â€“ Rollback incomplete work

> Uses **STEAL + NO-FORCE** policies and logs every step

### Recovery in Main-Memory DBs
- Main memory = volatile â†’ risk of loss
- Recovery must reload DB into memory and replay logs

âœ… Optimizations:
- Skip redo for indexes
- Do recovery in parallel across cores

---

## ğŸ’¡ What Iâ€™ve Learned
- ğŸ”„ Transactions must be safe and consistent
- ğŸ” Concurrency control is a balancing act
- ğŸ’¾ Recovery = logs, checkpoints, ARIES
- ğŸŒ High availability = backup systems and replication

---

## ğŸŒ± Reflection
From safe updates to post-crash recovery, this unit taught me that databases arenâ€™t just about data â€” theyâ€™re about trust.

Transactions, locks, logs, and backups:
The unsung heroes keeping our apps alive ğŸ’š

---

## ğŸ”š Conclusion
ACID, 2PL, ARIES, MVCC â€” they sound complex, but they all serve a simple purpose:
**Protect the data. Always. ğŸ›¡ï¸**

> ğŸ“ â€œA reliable system isnâ€™t the one that never fails.
Itâ€™s the one that knows how to recover.â€