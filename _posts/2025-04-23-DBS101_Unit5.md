---
Title: DBS101 Unit5
categories: [DBS101, Unit5]
tags: [DBS101]
---

# Unit V: The Secret Science Behind Smart Databases ðŸ§ ðŸ’¾

## ðŸ“Œ Introduction

This unit isnâ€™t just about writing queries â€” itâ€™s about designing **beautiful**, **reliable**, and **efficient** databases. Welcome to the world of **Relational Design**, **Normalization**, and **Functional Dependencies**.

If SQL were a city, this unit is where we design the *blueprint* for how everything fits together. Think of it as teaching your database how to stay tidy, avoid gossip (redundancy), and deal with life changes smoothly (anomalies). ðŸ˜‰

---

## ðŸ§± Lesson 12: Building Better Schemas â€“ Designing with Integrity

### âœ¨ Features of a Good Relational Design

| Feature                        | Why It Matters |
|-------------------------------|----------------|
| âœ… One Relation per Entity     | Keeps data organized |
| âœ… Fewer NULLs                | Prevents confusion |
| âœ… No Spurious Tuples         | Accurate joins |
| âœ… No Redundancy              | Saves space + avoids errors |
| âœ… No Modification Anomalies  | Smooth updates |

---

### ðŸŽ¨ 1. One Relation per Entity

Each table (relation) should describe a *single* thing (e.g., Student, Course). Donâ€™t mix attributes from different entities in one table â€” use **foreign keys** instead!

> ðŸŽ“ **Example:**  
Instead of mixing instructor and department in one table (`in_dep`), split them:
- Instructor(ID, name, salary, dept_name)  
- Department(dept_name, building, budget)

---

### ðŸ” 2. Minimize NULLs

NULLs = unknowns. Too many of them make your database messy and harder to manage.

> ðŸ”„ **Tip:** Move frequently NULL columns to a separate table and use the primary key as a link.

---

### ðŸ”„ 3. No Spurious Tuples (Lossless Joins)

Bad design = *weird results* from joins. To prevent this, designs should guarantee a **lossless join**.

> ðŸ’¡ **Definition:** A join is lossless if no extra (spurious) tuples appear when we decompose and rejoin tables.  
>  
> **Formula:**  
> `Ï€R1(r) â‹ˆ Ï€R2(r) = r`

---

### ðŸš« 4. Avoid Redundancy

Storing the same data in multiple places = recipe for disaster.

**Problems caused by redundancy:**
- Extra storage
- Repeated data entry
- Complex deletes/updates
- Anomalies!

---

### âš ï¸ 5. No Modification Anomalies

| Type        | What Happens |
|-------------|--------------|
| **Update**  | Change in one place, not others â†’ inconsistency |
| **Delete**  | Lose related data unintentionally |
| **Insert**  | Canâ€™t add data due to missing other info |

> ðŸ’­ Example: Can't add a student unless they enroll in a course? Youâ€™ve got an **insertion anomaly**.

---

### ðŸ§ª Normalization â€” Cleaning Up the Clutter

Normalization = turning chaos into order.

**Goal:**  
Split complex, messy tables into smaller, focused ones â€” without losing data!

---

### ðŸ“ Functional Dependencies (FDs)

FDs are rules that define how attributes relate.

**Example:**  
`A â†’ B` means: If you know A, you *must* know B.

#### ðŸ”§ Armstrongâ€™s Axioms

These are logic rules to find more dependencies:

- **Reflexivity:** If A âŠ‡ B â†’ A â†’ B  
- **Augmentation:** If A â†’ B â†’ AC â†’ BC  
- **Transitivity:** If A â†’ B and B â†’ C â†’ A â†’ C

---

### ðŸ”— Closure of FDs

Want to know *everything* a dependency set can tell you? Compute the **closure**!

> **Example:**  
F = { A â†’ B, B â†’ C }  
Aâº = { A, B, C }

---

### ðŸ”¥ Canonical Cover

Strip your dependencies down to the *bare minimum* (no extras!) while keeping meaning the same.

> ðŸ“‹ **Tip:** Remove redundant attributes from both sides of FDs.

---

### ðŸ§© Normal Forms â€” The Art of Designing Clean Databases

### ðŸ›  Normal Forms

| Normal Form | What It Solves                   |
|-------------|----------------------------------|
| **1NF**     | Atomic (no repeating groups)     |
| **2NF**     | Removes partial dependencies     |
| **3NF**     | Removes transitive dependencies  |
| **BCNF**    | Stronger version of 3NF          |
| **4NF/5NF** | Advanced multi-valued logic      |

---

### ðŸ” Lossless Decomposition

Split large relations into smaller ones â€” but **donâ€™t lose** any data!

**Goal:**  
`R â†’ R1, R2` such that `R1 â‹ˆ R2 = R`

---

### âœ… Dependency Preservation

After decomposition, you should still be able to enforce **all original FDs** without joining everything back.

> ðŸš¨ BCNF might break this! Thatâ€™s why we sometimes prefer **3NF**.

---

### ðŸ§® Testing Normal Forms

#### BCNF Check:
- Every non-trivial FD must have a **superkey** on the left side.

#### 3NF Check:
- Same as BCNF *or* every dependent attribute is part of a candidate key.

> ðŸ§ª **Tip:** Always start by finding the **closure of attributes** to check keys and violations.

---

### ðŸ¤– Algorithms for Decomposition

#### ðŸ“Š BCNF Algorithm:
- Find violating FD (where LHS isnâ€™t superkey)
- Decompose relation
- Repeat for resulting relations
- Always gives **lossless**, **BCNF-compliant** schemas

âš ï¸ Might lose dependency preservation.

---

#### âš™ï¸ 3NF Algorithm (Synthesis):

1. Compute **canonical cover** Fc  
2. Create new schema for each FD: Î± â†’ Î²  
3. Ensure at least one schema has a **candidate key**  
4. Remove redundant schemas

> âœ… Always lossless  
> âœ… Always dependency preserving  
> âš¡ Faster than BCNF decomposition!

---

## ðŸ“ˆ Lesson 13: Beyond Basics - MVDs, Atomicity, and Temporal Data

### ðŸ§¬ Multivalued Dependencies (MVD)
- BCNF doesn't remove **all** redundancies.
- Example: `inst(ID, dept_name, name, street, city)`
- Instructor may have multiple addresses and departments.

**Solution:**
- Break into smaller tables:
  - r1(ID, name)
  - r2(ID, street, city)

> **Fourth Normal Form (4NF)**: Handles multivalued dependencies. X â†’â†’ Y, where X is a superkey.

---

### ðŸ“‘ More Normal Forms

| Form | Purpose |
|------|---------|
| 4NF | Removes multivalued dependency redundancy |
| 5NF / PJNF | Removes join dependency redundancy |
| DKNF | Perfect design with all constraints |

> âš¡ **Reality Check**: DKNF and PJNF are complex and rarely used.

---

### ðŸ§± Atomic Domains and First Normal Form (1NF)
- **Atomic** = Indivisible values.
- **1NF Rule**: All attributes must be atomic.

**Non-Atomic Problems:**
- Redundancy
- Update complexity
- Difficult queries

**Solution:** Break complex attributes (e.g., `phone_numbers` âž” `phone1`, `phone2`, etc.).

---

### ðŸ— Database Design Process

#### âœï¸ Schema creation methods:
- Entity-Relationship (E-R) diagrams
- All-in-one large schema âž” Normalize
- Ad-hoc design âž” Normalize

**Good Practices:** Unique naming, listing keys first, clean E-R designs.

> ðŸ§¹ Normalize first for better scalability â€” but sometimes denormalize for performance (carefully!).

---

### â³ Modeling Temporal Data

#### ðŸ§­ Why temporal data?
- Some data changes over time (addresses, course titles).

**Handling Time:**
- Add `start_date` and `end_date` columns.
- Prevent overlapping valid periods with primary keys.

**Challenges:**
- Functional dependencies become time-sensitive.
- Primary/foreign keys must respect time.

> ðŸ“… **SQL:2011** added partial support for temporal data â€” but not full temporal queries.

---

## ðŸ’¡ What Iâ€™ve Learned

- ðŸŽ¯ How to design clean, efficient, and safe relational schemas  
- ðŸ” Why NULLs, anomalies, and redundancy are dangerous  
- ðŸ§  How to use Functional Dependencies and Armstrong's rules  
- ðŸ§° Algorithms to normalize data into 3NF or BCNF  

---

## ðŸŒ± Reflection

This unit transformed me from a query writer to a **data architect**.  
I now see that behind every good database is a well-thought design â€” not just good code.

---

## ðŸ”š Conclusion

Databases arenâ€™t just about *queries*. Theyâ€™re about **structure**, **logic**, and **efficiency**. With FDs, Normal Forms, and Design Theory â€” I can now build systems that scale, survive, and make data make sense.

> ðŸŽ“ **Did You Know?** Edgar Codd, the father of relational databases, introduced normalization to reduce anomalies and improve integrity â€” and weâ€™re still using his rules today!
